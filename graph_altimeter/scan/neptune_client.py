"""This modules provides the class ``GraphAltimeterNeptuneClient`` that allows
to write a graph generated by Altimeter as a Security Graph universe
snapshot."""

import logging

from gremlin_python.process.traversal import T
from gremlin_python.process.graph_traversal import __
from altimeter.core.neptune.client import (
    AltimeterNeptuneClient,
    NeptuneEndpoint,
    NeptuneNoGraphsFoundException,
    NeptuneLoadGraphException
)


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


# pylint: disable=arguments-differ
class GraphAltimeterNeptuneClient(AltimeterNeptuneClient):
    """Client to store a graph generated by Altimeter into a Neptune
    compatible database following the Security Graph Universe schema.

    Args:
        neptune_endpoint: NeptuneEndpoint object for this client"""

    def __init__(self, endpoint: NeptuneEndpoint):
        # We the max_age_min is not used lpg's graphs.
        super().__init__(0, endpoint)
        self.logger = logger

    def write_to_neptune_lpg(self, graph, scan_id, vertex_id):
        """Write a graph generated by an Altimeter scan to a Neptune
        database, ensuring that whenever a vertex is written, it is liked
        to the given vertex id."""
        if "vertices" in graph and "edges" in graph \
                and len(graph["vertices"]) > 0:
            g, conn = self.connect_to_gremlin()
            self.__write_vertices(g, graph["vertices"], scan_id, vertex_id)
            self.__write_edges(g, graph["edges"], scan_id)
            conn.close()
        else:
            raise NeptuneNoGraphsFoundException

    # pylint: disable=invalid-name
    def __write_vertices(self, g, vertices, scan_id, link_from_id):
        """Writes the provided vertices dictionary to a labeled graph
        ensuring each new vertex is linked to the vertex identified by the
        link_from_id param"""
        cnt = 0
        t = g
        for r in vertices:
            vertex_id = f'{r["~id"]}_{scan_id}'
            t = (
                    t.V(vertex_id)
                    .fold()
                    .coalesce(
                        __.unfold(),
                        __.addV(self.parse_arn(r["~label"])["resource"])
                        .property(T.id, vertex_id)
                        .sideEffect(
                            __.addE("includes")
                            .from_(link_from_id)
                        )
                    )
            )

            for k in r.keys():
                # Need to handle numbers that are bigger than a Long in Java,
                # for now we stringify it
                if isinstance(r[k], int) and (
                    r[k] > 9223372036854775807 or r[k] < -9223372036854775807
                ):
                    r[k] = str(r[k])
                if k not in ["~id", "~label"]:
                    t = t.property(k, r[k])
            cnt += 1
            if cnt % 100 == 0 or cnt == len(vertices):
                try:
                    self.logger.info(
                        "Writing vertices %i of %i",
                        cnt,
                        len(vertices)
                    )
                    t.next()
                    t = g
                except Exception as err:
                    self.logger.error(str(err))
                    raise NeptuneLoadGraphException(
                        f"Error loading vertex {r} " f"with {str(t.bytecode)}"
                    ) from err

    def __write_edges(self, g, edges, scan_id):
        """
        Writes the edges to the labeled property graph
        :param g: The graph traversal source
        :param edges: A list of dictionaries for each edge
        :return: None
        """
        cnt = 0
        t = g
        for r in edges:
            to_id = f'{r["~to"]}_{scan_id}'
            from_id = f'{r["~from"]}_{scan_id}'
            t = (
                t.addE(r["~label"])
                .property(T.id, str(r["~id"]))
                .from_(
                    __.V(from_id)
                    .fold()
                    .coalesce(
                        __.unfold(),
                        __.addV(self.parse_arn(r["~from"])["resource"])
                        .property(T.id, from_id)
                        .property("scan_id", scan_id)
                        .property("arn", str(r["~from"])),
                    )
                )
                .to(
                    __.V(to_id)
                    .fold()
                    .coalesce(
                        __.unfold(),
                        __.addV(self.parse_arn(r["~to"])["resource"])
                        .property(T.id, to_id)
                        .property("scan_id", scan_id)
                        .property("arn", str(r["~to"])),
                    )
                )
            )
            cnt += 1
            if cnt % 100 == 0 or cnt == len(edges):
                try:
                    self.logger.info(
                        "Writing edges %i of %i",
                        cnt,
                        len(edges)
                    )
                    t.next()
                    t = g
                except Exception as err:
                    self.logger.error(str(err))
                    raise NeptuneLoadGraphException(
                        f"Error loading edge {r} " f"with {str(t.bytecode)}"
                    ) from err
